/*
 * (C) Copyright 2012 Henrik Nordstrom <henrik@henriknordstrom.net>
 *
 * (C) Copyright 2007-2011
 * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
 * Tom Cubie <tangliang@allwinnertech.com>
 *
 * Some init for sunxi platform.
 *
 * SPDX-License-Identifier:	GPL-2.0+
 */

#include <common.h>
#include <mmc.h>
#include <i2c.h>
#include <serial.h>
#ifdef CONFIG_SPL_BUILD
#include <spl.h>
#endif
#include <asm/gpio.h>
#include <asm/io.h>
#include <asm/arch/clock.h>
#include <asm/arch/gpio.h>
#include <asm/arch/spl.h>
#include <asm/arch/sys_proto.h>
#include <asm/arch/timer.h>
#include <asm/arch/tzpc.h>
#include <asm/arch/mmc.h>

#include <linux/compiler.h>

#ifndef CONFIG_SPL_BUILD
/* A generic device independent uart0 helloword payload - https://github.com/linux-sunxi/sunxi-tools/pull/44 */
static char spi_flash_data[8192] = {
	0x06, 0x00, 0x00, 0xEA, 0x65, 0x47, 0x4F, 0x4E, 0x2E, 0x42, 0x54, 0x30, 0x6A, 0x85, 0xFA, 0xB7, 0x00,
	0x20, 0x00, 0x00, 0x53, 0x50, 0x4C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0x01,
	0x00, 0xEA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xA0, 0x32, 0xA0,
	0xE1, 0x24, 0xC0, 0xA0, 0xE3, 0xD0, 0x21, 0xE1, 0xE7, 0x07, 0x00, 0x00, 0xE2, 0x9C, 0x03, 0x03, 0xE0,
	0x00, 0x01, 0xA0, 0xE1, 0x10, 0x40, 0x2D, 0xE9, 0x0F, 0x40, 0xA0, 0xE3, 0x07, 0x35, 0x83, 0xE2, 0x82,
	0x3B, 0x83, 0xE2, 0x02, 0xC1, 0x93, 0xE7, 0x14, 0xC0, 0xCC, 0xE1, 0x11, 0x10, 0x8C, 0xE1, 0x00, 0x00,
	0xA0, 0xE3, 0x02, 0x11, 0x83, 0xE7, 0x10, 0x80, 0xBD, 0xE8, 0xA0, 0x22, 0xA0, 0xE1, 0x24, 0xC0, 0xA0,
	0xE3, 0x50, 0x32, 0xE0, 0xE7, 0x0F, 0x00, 0x00, 0xE2, 0x9C, 0x02, 0x02, 0xE0, 0x06, 0x30, 0x83, 0xE2,
	0x80, 0x00, 0xA0, 0xE1, 0x03, 0xC0, 0xA0, 0xE3, 0x07, 0x25, 0x82, 0xE2, 0x82, 0x2B, 0x82, 0xE2, 0x03,
	0x31, 0x82, 0xE0, 0x04, 0x20, 0x93, 0xE5, 0x1C, 0x20, 0xC2, 0xE1, 0x11, 0x10, 0x82, 0xE1, 0x00, 0x00,
	0xA0, 0xE3, 0x04, 0x10, 0x83, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0x1F, 0xC0, 0x00, 0xE2, 0xA0, 0x02, 0xA0,
	0xE1, 0x24, 0x30, 0xA0, 0xE3, 0x00, 0x00, 0x51, 0xE3, 0x93, 0x00, 0x03, 0xE0, 0x01, 0x10, 0xA0, 0xE3,
	0x00, 0x00, 0xA0, 0xE3, 0x07, 0x35, 0x83, 0xE2, 0x82, 0x3B, 0x83, 0xE2, 0x10, 0x20, 0x93, 0xE5, 0x11,
	0x2C, 0x82, 0x11, 0x11, 0x2C, 0xC2, 0x01, 0x10, 0x20, 0x83, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0xA0, 0x32,
	0xA0, 0xE1, 0x24, 0x20, 0xA0, 0xE3, 0x1F, 0x00, 0x00, 0xE2, 0x92, 0x03, 0x03, 0xE0, 0x07, 0x35, 0x83,
	0xE2, 0x82, 0x3B, 0x83, 0xE2, 0x10, 0x30, 0x93, 0xE5, 0x33, 0x00, 0xA0, 0xE1, 0x01, 0x00, 0x00, 0xE2,
	0x1E, 0xFF, 0x2F, 0xE1, 0x10, 0x40, 0x2D, 0xE9, 0x00, 0x10, 0xA0, 0xE3, 0x00, 0x40, 0xA0, 0xE1, 0xC2,
	0xFF, 0xFF, 0xEB, 0x04, 0x00, 0xA0, 0xE1, 0x10, 0x40, 0xBD, 0xE8, 0xEE, 0xFF, 0xFF, 0xEA, 0x38, 0x40,
	0x2D, 0xE9, 0x01, 0x40, 0xA0, 0xE1, 0x01, 0x10, 0xA0, 0xE3, 0x00, 0x50, 0xA0, 0xE1, 0xBA, 0xFF, 0xFF,
	0xEB, 0x05, 0x00, 0xA0, 0xE1, 0x04, 0x10, 0xA0, 0xE1, 0x38, 0x40, 0xBD, 0xE8, 0xD7, 0xFF, 0xFF, 0xEA,
	0x10, 0x2F, 0x10, 0xEE, 0x52, 0x22, 0xEB, 0xE7, 0x0F, 0x3C, 0x00, 0xE3, 0x03, 0x00, 0x52, 0xE1, 0x30,
	0x30, 0x9F, 0x05, 0x39, 0x26, 0x01, 0x03, 0x03, 0x30, 0x8F, 0x00, 0x07, 0x00, 0x00, 0x0A, 0x07, 0x35,
	0xA0, 0xE3, 0x24, 0x20, 0x93, 0xE5, 0x02, 0x29, 0x82, 0xE3, 0x24, 0x20, 0x83, 0xE5, 0x24, 0x20, 0x93,
	0xE5, 0x10, 0x30, 0x9F, 0xE5, 0x22, 0x28, 0xA0, 0xE1, 0x03, 0x30, 0x8F, 0xE0, 0x00, 0x20, 0x83, 0xE5,
	0x1E, 0xFF, 0x2F, 0xE1, 0x54, 0x06, 0x00, 0x00, 0x30, 0x06, 0x00, 0x00, 0x14, 0x30, 0x9F, 0xE5, 0x03,
	0x00, 0x9F, 0xE7, 0x23, 0x36, 0x01, 0xE3, 0x03, 0x30, 0x50, 0xE0, 0x00, 0x00, 0x73, 0xE2, 0x03, 0x00,
	0xB0, 0xE0, 0x1E, 0xFF, 0x2F, 0xE1, 0x18, 0x06, 0x00, 0x00, 0x30, 0x30, 0x9F, 0xE5, 0x03, 0x20, 0x9F,
	0xE7, 0x25, 0x36, 0x01, 0xE3, 0x03, 0x00, 0x52, 0xE1, 0x06, 0x00, 0x00, 0x1A, 0x20, 0x30, 0x9F, 0xE5,
	0x08, 0x08, 0x93, 0xE5, 0x50, 0x06, 0xE3, 0xE7, 0x07, 0x30, 0x50, 0xE2, 0x00, 0x00, 0x73, 0xE2, 0x03,
	0x00, 0xB0, 0xE0, 0x1E, 0xFF, 0x2F, 0xE1, 0x00, 0x00, 0xA0, 0xE3, 0x1E, 0xFF, 0x2F, 0xE1, 0xF8, 0x05,
	0x00, 0x00, 0x00, 0x30, 0xC2, 0x01, 0x2C, 0x30, 0x9F, 0xE5, 0x03, 0x20, 0x9F, 0xE7, 0x25, 0x36, 0x01,
	0xE3, 0x03, 0x00, 0x52, 0xE1, 0x05, 0x00, 0x00, 0x1A, 0x1C, 0x30, 0x9F, 0xE5, 0x08, 0x08, 0x93, 0xE5,
	0x50, 0x06, 0xE3, 0xE7, 0x07, 0x00, 0x50, 0xE2, 0x01, 0x00, 0xA0, 0x13, 0x1E, 0xFF, 0x2F, 0xE1, 0x00,
	0x00, 0xA0, 0xE3, 0x1E, 0xFF, 0x2F, 0xE1, 0xB8, 0x05, 0x00, 0x00, 0x00, 0x30, 0xC2, 0x01, 0x14, 0x30,
	0x9F, 0xE5, 0x03, 0x00, 0x9F, 0xE7, 0x51, 0x36, 0x01, 0xE3, 0x03, 0x30, 0x50, 0xE0, 0x00, 0x00, 0x73,
	0xE2, 0x03, 0x00, 0xB0, 0xE0, 0x1E, 0xFF, 0x2F, 0xE1, 0x7C, 0x05, 0x00, 0x00, 0x14, 0x30, 0x9F, 0xE5,
	0x03, 0x00, 0x9F, 0xE7, 0x33, 0x36, 0x01, 0xE3, 0x03, 0x30, 0x50, 0xE0, 0x00, 0x00, 0x73, 0xE2, 0x03,
	0x00, 0xB0, 0xE0, 0x1E, 0xFF, 0x2F, 0xE1, 0x5C, 0x05, 0x00, 0x00, 0x14, 0x30, 0x9F, 0xE5, 0x03, 0x00,
	0x9F, 0xE7, 0x39, 0x36, 0x01, 0xE3, 0x03, 0x30, 0x50, 0xE0, 0x00, 0x00, 0x73, 0xE2, 0x03, 0x00, 0xB0,
	0xE0, 0x1E, 0xFF, 0x2F, 0xE1, 0x3C, 0x05, 0x00, 0x00, 0x14, 0x30, 0x9F, 0xE5, 0x03, 0x00, 0x9F, 0xE7,
	0x89, 0x36, 0x01, 0xE3, 0x03, 0x30, 0x50, 0xE0, 0x00, 0x00, 0x73, 0xE2, 0x03, 0x00, 0xB0, 0xE0, 0x1E,
	0xFF, 0x2F, 0xE1, 0x1C, 0x05, 0x00, 0x00, 0x10, 0x30, 0x9F, 0xE5, 0x03, 0x00, 0x9F, 0xE7, 0x5A, 0x3D,
	0x50, 0xE2, 0x00, 0x00, 0x73, 0xE2, 0x03, 0x00, 0xB0, 0xE0, 0x1E, 0xFF, 0x2F, 0xE1, 0xFC, 0x04, 0x00,
	0x00, 0x18, 0x30, 0x9F, 0xE5, 0x6C, 0x20, 0x93, 0xE5, 0x01, 0x28, 0x82, 0xE3, 0x6C, 0x20, 0x83, 0xE5,
	0xD8, 0x22, 0x93, 0xE5, 0x01, 0x28, 0x82, 0xE3, 0xD8, 0x22, 0x83, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0x00,
	0x00, 0xC2, 0x01, 0x08, 0x40, 0x2D, 0xE9, 0xA6, 0xFF, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0x07, 0x00,
	0x00, 0x0A, 0x02, 0x10, 0xA0, 0xE3, 0x36, 0x00, 0xA0, 0xE3, 0x44, 0xFF, 0xFF, 0xEB, 0x37, 0x00, 0xA0,
	0xE3, 0x02, 0x10, 0xA0, 0xE3, 0x41, 0xFF, 0xFF, 0xEB, 0x37, 0x00, 0xA0, 0xE3, 0x3C, 0x00, 0x00, 0xEA,
	0xC2, 0xFF, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0xF4, 0xFF, 0xFF, 0x1A, 0xA0, 0xFF, 0xFF, 0xEB, 0x00,
	0x00, 0x50, 0xE3, 0x07, 0x00, 0x00, 0x0A, 0x02, 0x10, 0xA0, 0xE3, 0x33, 0x00, 0xA0, 0xE3, 0x36, 0xFF,
	0xFF, 0xEB, 0x34, 0x00, 0xA0, 0xE3, 0x02, 0x10, 0xA0, 0xE3, 0x33, 0xFF, 0xFF, 0xEB, 0x34, 0x00, 0xA0,
	0xE3, 0x2E, 0x00, 0x00, 0xEA, 0xA5, 0xFF, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0x0B, 0x00, 0x00, 0x0A,
	0x33, 0x00, 0xA0, 0xE3, 0x65, 0xFF, 0xFF, 0xEB, 0x34, 0x00, 0xA0, 0xE3, 0x63, 0xFF, 0xFF, 0xEB, 0x04,
	0x10, 0xA0, 0xE3, 0xA2, 0x00, 0xA0, 0xE3, 0x27, 0xFF, 0xFF, 0xEB, 0xA4, 0x00, 0xA0, 0xE3, 0x04, 0x10,
	0xA0, 0xE3, 0x24, 0xFF, 0xFF, 0xEB, 0xA4, 0x00, 0xA0, 0xE3, 0x1F, 0x00, 0x00, 0xEA, 0xAD, 0xFF, 0xFF,
	0xEB, 0x00, 0x00, 0x50, 0xE3, 0x07, 0x00, 0x00, 0x0A, 0x02, 0x10, 0xA0, 0xE3, 0xF4, 0x00, 0xA0, 0xE3,
	0x1C, 0xFF, 0xFF, 0xEB, 0xF5, 0x00, 0xA0, 0xE3, 0x02, 0x10, 0xA0, 0xE3, 0x19, 0xFF, 0xFF, 0xEB, 0xF5,
	0x00, 0xA0, 0xE3, 0x14, 0x00, 0x00, 0xEA, 0xB2, 0xFF, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0x07, 0x00,
	0x00, 0x0A, 0x04, 0x10, 0xA0, 0xE3, 0x28, 0x00, 0xA0, 0xE3, 0x11, 0xFF, 0xFF, 0xEB, 0x29, 0x00, 0xA0,
	0xE3, 0x04, 0x10, 0xA0, 0xE3, 0x0E, 0xFF, 0xFF, 0xEB, 0x29, 0x00, 0xA0, 0xE3, 0x09, 0x00, 0x00, 0xEA,
	0xAF, 0xFF, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0x09, 0x00, 0x00, 0x0A, 0x02, 0x10, 0xA0, 0xE3, 0x04,
	0x00, 0xA0, 0xE3, 0x06, 0xFF, 0xFF, 0xEB, 0x05, 0x00, 0xA0, 0xE3, 0x02, 0x10, 0xA0, 0xE3, 0x03, 0xFF,
	0xFF, 0xEB, 0x05, 0x00, 0xA0, 0xE3, 0x01, 0x10, 0xA0, 0xE3, 0x08, 0x40, 0xBD, 0xE8, 0x0F, 0xFF, 0xFF,
	0xEA, 0xFE, 0xFF, 0xFF, 0xEA, 0x08, 0x40, 0x2D, 0xE9, 0xA7, 0xFF, 0xFF, 0xEB, 0x80, 0x20, 0xA0, 0xE3,
	0x1C, 0x30, 0x9F, 0xE5, 0x0C, 0x20, 0x83, 0xE5, 0x00, 0x20, 0xA0, 0xE3, 0x04, 0x20, 0x83, 0xE5, 0x0D,
	0x20, 0xA0, 0xE3, 0x00, 0x20, 0x83, 0xE5, 0x03, 0x20, 0xA0, 0xE3, 0x0C, 0x20, 0x83, 0xE5, 0x08, 0x80,
	0xBD, 0xE8, 0x00, 0x80, 0xC2, 0x01, 0x14, 0x20, 0x9F, 0xE5, 0x14, 0x30, 0x92, 0xE5, 0x40, 0x00, 0x13,
	0xE3, 0xFC, 0xFF, 0xFF, 0x0A, 0x04, 0x30, 0x9F, 0xE5, 0x00, 0x00, 0x83, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1,
	0x00, 0x80, 0xC2, 0x01, 0x10, 0x40, 0x2D, 0xE9, 0x00, 0x40, 0xA0, 0xE1, 0x05, 0x00, 0x00, 0xEA, 0x0A,
	0x00, 0x53, 0xE3, 0x01, 0x00, 0x00, 0x1A, 0x0D, 0x00, 0xA0, 0xE3, 0xF0, 0xFF, 0xFF, 0xEB, 0x01, 0x00,
	0x54, 0xE5, 0xEE, 0xFF, 0xFF, 0xEB, 0x01, 0x30, 0xD4, 0xE4, 0x00, 0x00, 0x53, 0xE3, 0xF6, 0xFF, 0xFF,
	0x1A, 0x10, 0x80, 0xBD, 0xE8, 0x08, 0x40, 0x2D, 0xE9, 0x76, 0xFF, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3,
	0x01, 0x08, 0xA0, 0x13, 0x04, 0x00, 0x00, 0x1A, 0x6A, 0xFF, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0x01,
	0x08, 0xA0, 0x13, 0x00, 0x00, 0xA0, 0x03, 0xFF, 0xFF, 0xFF, 0xEA, 0x04, 0x20, 0x90, 0xE5, 0x40, 0x30,
	0x9F, 0xE5, 0x03, 0x00, 0x52, 0xE1, 0x0A, 0x00, 0x00, 0x1A, 0x08, 0x20, 0x90, 0xE5, 0x34, 0x30, 0x9F,
	0xE5, 0x03, 0x00, 0x52, 0xE1, 0x06, 0x00, 0x00, 0x1A, 0x28, 0x00, 0xD0, 0xE5, 0x00, 0x00, 0x50, 0xE3,
	0x05, 0x00, 0x00, 0x0A, 0x03, 0x00, 0x50, 0xE3, 0x03, 0x00, 0xA0, 0x03, 0x00, 0x00, 0xA0, 0x13, 0x08,
	0x80, 0xBD, 0xE8, 0x01, 0x00, 0xA0, 0xE3, 0x08, 0x80, 0xBD, 0xE8, 0x02, 0x00, 0xA0, 0xE3, 0x08, 0x80,
	0xBD, 0xE8, 0x65, 0x47, 0x4F, 0x4E, 0x2E, 0x42, 0x54, 0x30, 0x0A, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20,
	0x66, 0x72, 0x6F, 0x6D, 0x20, 0x00, 0x41, 0x6C, 0x6C, 0x77, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 0x41,
	0x31, 0x30, 0x21, 0x0A, 0x00, 0x41, 0x6C, 0x6C, 0x77, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 0x41, 0x31,
	0x30, 0x73, 0x21, 0x0A, 0x00, 0x41, 0x6C, 0x6C, 0x77, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 0x41, 0x31,
	0x33, 0x21, 0x0A, 0x00, 0x41, 0x6C, 0x6C, 0x77, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 0x41, 0x32, 0x30,
	0x21, 0x0A, 0x00, 0x41, 0x6C, 0x6C, 0x77, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 0x41, 0x33, 0x31, 0x2F,
	0x41, 0x33, 0x31, 0x73, 0x21, 0x0A, 0x00, 0x41, 0x6C, 0x6C, 0x77, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20,
	0x41, 0x36, 0x34, 0x21, 0x0A, 0x00, 0x41, 0x6C, 0x6C, 0x77, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 0x48,
	0x33, 0x21, 0x0A, 0x00, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x41, 0x6C, 0x6C, 0x77, 0x69,
	0x6E, 0x6E, 0x65, 0x72, 0x20, 0x53, 0x6F, 0x43, 0x21, 0x0A, 0x00, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E,
	0x69, 0x6E, 0x67, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x74, 0x6F, 0x20, 0x46, 0x45, 0x4C, 0x2E, 0x0A,
	0x00, 0x42, 0x6F, 0x6F, 0x74, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x4D, 0x4D, 0x43, 0x30,
	0x2C, 0x20, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x66,
	0x69, 0x6E, 0x69, 0x74, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2E, 0x0A, 0x00, 0x42, 0x6F, 0x6F, 0x74,
	0x65, 0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x53, 0x50, 0x49, 0x30, 0x2C, 0x20, 0x65, 0x6E, 0x74,
	0x65, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x66, 0x69, 0x6E, 0x69, 0x74, 0x65,
	0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2E, 0x0A, 0x00, 0x42, 0x6F, 0x6F, 0x74, 0x65, 0x64, 0x20, 0x66, 0x72,
	0x6F, 0x6D, 0x20, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x2C,
	0x20, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x66, 0x69,
	0x6E, 0x69, 0x74, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x08, 0x40,
	0x2D, 0xE9, 0xB2, 0xFE, 0xFF, 0xEB, 0x1C, 0xFF, 0xFF, 0xEB, 0x68, 0xFF, 0xFF, 0xEB, 0xFC, 0x00, 0x9F,
	0xE5, 0x00, 0x00, 0x8F, 0xE0, 0x7A, 0xFF, 0xFF, 0xEB, 0xC0, 0xFE, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3,
	0xEC, 0x00, 0x9F, 0x15, 0x00, 0x00, 0x8F, 0x10, 0x1E, 0x00, 0x00, 0x1A, 0xC3, 0xFE, 0xFF, 0xEB, 0x00,
	0x00, 0x50, 0xE3, 0xDC, 0x00, 0x9F, 0x15, 0x00, 0x00, 0x8F, 0x10, 0x19, 0x00, 0x00, 0x1A, 0xCE, 0xFE,
	0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0xCC, 0x00, 0x9F, 0x15, 0x00, 0x00, 0x8F, 0x10, 0x14, 0x00, 0x00,
	0x1A, 0xD8, 0xFE, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0xBC, 0x00, 0x9F, 0x15, 0x00, 0x00, 0x8F, 0x10,
	0x0F, 0x00, 0x00, 0x1A, 0xDB, 0xFE, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0xAC, 0x00, 0x9F, 0x15, 0x00,
	0x00, 0x8F, 0x10, 0x0A, 0x00, 0x00, 0x1A, 0xE6, 0xFE, 0xFF, 0xEB, 0x00, 0x00, 0x50, 0xE3, 0x9C, 0x00,
	0x9F, 0x15, 0x00, 0x00, 0x8F, 0x10, 0x05, 0x00, 0x00, 0x1A, 0xE9, 0xFE, 0xFF, 0xEB, 0x00, 0x00, 0x50,
	0xE3, 0x8C, 0x00, 0x9F, 0x15, 0x00, 0x00, 0x8F, 0x10, 0x88, 0x00, 0x9F, 0x05, 0x00, 0x00, 0x8F, 0x00,
	0x55, 0xFF, 0xFF, 0xEB, 0x61, 0xFF, 0xFF, 0xEB, 0x02, 0x00, 0x50, 0xE3, 0x04, 0x00, 0x00, 0x0A, 0x03,
	0x00, 0x50, 0xE3, 0x06, 0x00, 0x00, 0x0A, 0x01, 0x00, 0x50, 0xE3, 0x08, 0x00, 0x00, 0x1A, 0x0B, 0x00,
	0x00, 0xEA, 0x60, 0x00, 0x9F, 0xE5, 0x00, 0x00, 0x8F, 0xE0, 0x4A, 0xFF, 0xFF, 0xEB, 0xFE, 0xFF, 0xFF,
	0xEA, 0x54, 0x00, 0x9F, 0xE5, 0x00, 0x00, 0x8F, 0xE0, 0x46, 0xFF, 0xFF, 0xEB, 0xFE, 0xFF, 0xFF, 0xEA,
	0x48, 0x00, 0x9F, 0xE5, 0x00, 0x00, 0x8F, 0xE0, 0x42, 0xFF, 0xFF, 0xEB, 0xFE, 0xFF, 0xFF, 0xEA, 0x3C,
	0x00, 0x9F, 0xE5, 0x00, 0x00, 0x8F, 0xE0, 0x3E, 0xFF, 0xFF, 0xEB, 0x00, 0x00, 0xA0, 0xE3, 0x08, 0x80,
	0xBD, 0xE8, 0x9C, 0xFE, 0xFF, 0xFF, 0x95, 0xFE, 0xFF, 0xFF, 0x91, 0xFE, 0xFF, 0xFF, 0x8E, 0xFE, 0xFF,
	0xFF, 0x8A, 0xFE, 0xFF, 0xFF, 0x86, 0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x83, 0xFE, 0xFF, 0xFF,
	0x8A, 0xFE, 0xFF, 0xFF, 0x8E, 0xFE, 0xFF, 0xFF, 0xAC, 0xFE, 0xFF, 0xFF, 0xCA, 0xFE, 0xFF, 0xFF, 0x46,
	0xFE, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#endif

struct fel_stash {
	uint32_t sp;
	uint32_t lr;
	uint32_t cpsr;
	uint32_t sctlr;
	uint32_t vbar;
	uint32_t cr;
};

struct fel_stash fel_stash __attribute__((section(".data")));

static int gpio_init(void)
{
#if CONFIG_CONS_INDEX == 1 && defined(CONFIG_UART0_PORT_F)
#if defined(CONFIG_MACH_SUN4I) || defined(CONFIG_MACH_SUN7I)
	/* disable GPB22,23 as uart0 tx,rx to avoid conflict */
	sunxi_gpio_set_cfgpin(SUNXI_GPB(22), SUNXI_GPIO_INPUT);
	sunxi_gpio_set_cfgpin(SUNXI_GPB(23), SUNXI_GPIO_INPUT);
#endif
#if defined(CONFIG_MACH_SUN8I)
	sunxi_gpio_set_cfgpin(SUNXI_GPF(2), SUN8I_GPF_UART0);
	sunxi_gpio_set_cfgpin(SUNXI_GPF(4), SUN8I_GPF_UART0);
#else
	sunxi_gpio_set_cfgpin(SUNXI_GPF(2), SUNXI_GPF_UART0);
	sunxi_gpio_set_cfgpin(SUNXI_GPF(4), SUNXI_GPF_UART0);
#endif
	sunxi_gpio_set_pull(SUNXI_GPF(4), 1);
#elif CONFIG_CONS_INDEX == 1 && (defined(CONFIG_MACH_SUN4I) || defined(CONFIG_MACH_SUN7I))
	sunxi_gpio_set_cfgpin(SUNXI_GPB(22), SUN4I_GPB_UART0);
	sunxi_gpio_set_cfgpin(SUNXI_GPB(23), SUN4I_GPB_UART0);
	sunxi_gpio_set_pull(SUNXI_GPB(23), SUNXI_GPIO_PULL_UP);
#elif CONFIG_CONS_INDEX == 1 && defined(CONFIG_MACH_SUN5I)
	sunxi_gpio_set_cfgpin(SUNXI_GPB(19), SUN5I_GPB_UART0);
	sunxi_gpio_set_cfgpin(SUNXI_GPB(20), SUN5I_GPB_UART0);
	sunxi_gpio_set_pull(SUNXI_GPB(20), SUNXI_GPIO_PULL_UP);
#elif CONFIG_CONS_INDEX == 1 && defined(CONFIG_MACH_SUN6I)
	sunxi_gpio_set_cfgpin(SUNXI_GPH(20), SUN6I_GPH_UART0);
	sunxi_gpio_set_cfgpin(SUNXI_GPH(21), SUN6I_GPH_UART0);
	sunxi_gpio_set_pull(SUNXI_GPH(21), SUNXI_GPIO_PULL_UP);
#elif CONFIG_CONS_INDEX == 1 && defined(CONFIG_MACH_SUN8I_A33)
	sunxi_gpio_set_cfgpin(SUNXI_GPB(0), SUN8I_A33_GPB_UART0);
	sunxi_gpio_set_cfgpin(SUNXI_GPB(1), SUN8I_A33_GPB_UART0);
	sunxi_gpio_set_pull(SUNXI_GPB(1), SUNXI_GPIO_PULL_UP);
#elif CONFIG_CONS_INDEX == 1 && defined(CONFIG_MACH_SUN8I_H3)
	sunxi_gpio_set_cfgpin(SUNXI_GPA(4), SUN8I_H3_GPA_UART0);
	sunxi_gpio_set_cfgpin(SUNXI_GPA(5), SUN8I_H3_GPA_UART0);
	sunxi_gpio_set_pull(SUNXI_GPA(5), SUNXI_GPIO_PULL_UP);
#elif CONFIG_CONS_INDEX == 1 && defined(CONFIG_MACH_SUN8I_A83T)
	sunxi_gpio_set_cfgpin(SUNXI_GPB(9), SUN8I_A83T_GPB_UART0);
	sunxi_gpio_set_cfgpin(SUNXI_GPB(10), SUN8I_A83T_GPB_UART0);
	sunxi_gpio_set_pull(SUNXI_GPB(10), SUNXI_GPIO_PULL_UP);
#elif CONFIG_CONS_INDEX == 1 && defined(CONFIG_MACH_SUN9I)
	sunxi_gpio_set_cfgpin(SUNXI_GPH(12), SUN9I_GPH_UART0);
	sunxi_gpio_set_cfgpin(SUNXI_GPH(13), SUN9I_GPH_UART0);
	sunxi_gpio_set_pull(SUNXI_GPH(13), SUNXI_GPIO_PULL_UP);
#elif CONFIG_CONS_INDEX == 2 && defined(CONFIG_MACH_SUN5I)
	sunxi_gpio_set_cfgpin(SUNXI_GPG(3), SUN5I_GPG_UART1);
	sunxi_gpio_set_cfgpin(SUNXI_GPG(4), SUN5I_GPG_UART1);
	sunxi_gpio_set_pull(SUNXI_GPG(4), SUNXI_GPIO_PULL_UP);
#elif CONFIG_CONS_INDEX == 3 && defined(CONFIG_MACH_SUN8I)
	sunxi_gpio_set_cfgpin(SUNXI_GPB(0), SUN8I_GPB_UART2);
	sunxi_gpio_set_cfgpin(SUNXI_GPB(1), SUN8I_GPB_UART2);
	sunxi_gpio_set_pull(SUNXI_GPB(1), SUNXI_GPIO_PULL_UP);
#elif CONFIG_CONS_INDEX == 5 && defined(CONFIG_MACH_SUN8I)
	sunxi_gpio_set_cfgpin(SUNXI_GPL(2), SUN8I_GPL_R_UART);
	sunxi_gpio_set_cfgpin(SUNXI_GPL(3), SUN8I_GPL_R_UART);
	sunxi_gpio_set_pull(SUNXI_GPL(3), SUNXI_GPIO_PULL_UP);
#else
#error Unsupported console port number. Please fix pin mux settings in board.c
#endif

	return 0;
}

int spl_board_load_image(void)
{
	debug("Returning to FEL sp=%x, lr=%x\n", fel_stash.sp, fel_stash.lr);
	return_to_fel(fel_stash.sp, fel_stash.lr);

	return 0;
}

void s_init(void)
{
#if defined CONFIG_MACH_SUN6I || defined CONFIG_MACH_SUN8I_A23
	/* Magic (undocmented) value taken from boot0, without this DRAM
	 * access gets messed up (seems cache related) */
	setbits_le32(SUNXI_SRAMC_BASE + 0x44, 0x1800);
#endif
#if defined CONFIG_MACH_SUN6I || \
    defined CONFIG_MACH_SUN7I || \
    defined CONFIG_MACH_SUN8I
	/* Enable SMP mode for CPU0, by setting bit 6 of Auxiliary Ctl reg */
	asm volatile(
		"mrc p15, 0, r0, c1, c0, 1\n"
		"orr r0, r0, #1 << 6\n"
		"mcr p15, 0, r0, c1, c0, 1\n");
#endif
#if defined CONFIG_MACH_SUN6I || defined CONFIG_MACH_SUN8I_H3
	/* Enable non-secure access to some peripherals */
	tzpc_init();
#endif

	clock_init();
	timer_init();
	gpio_init();
	i2c_init_board();
}

#ifdef CONFIG_SPL_BUILD
DECLARE_GLOBAL_DATA_PTR;

/* The sunxi internal brom will try to loader external bootloader
 * from mmc0, nand flash, mmc2.
 */
u32 spl_boot_device(void)
{
	__maybe_unused struct mmc *mmc0, *mmc1;
	/*
	 * When booting from the SD card or NAND memory, the "eGON.BT0"
	 * signature is expected to be found in memory at the address 0x0004
	 * (see the "mksunxiboot" tool, which generates this header).
	 *
	 * When booting in the FEL mode over USB, this signature is patched in
	 * memory and replaced with something else by the 'fel' tool. This other
	 * signature is selected in such a way, that it can't be present in a
	 * valid bootable SD card image (because the BROM would refuse to
	 * execute the SPL in this case).
	 *
	 * This checks for the signature and if it is not found returns to
	 * the FEL code in the BROM to wait and receive the main u-boot
	 * binary over USB. If it is found, it determines where SPL was
	 * read from.
	 */
	if (!is_boot0_magic(SPL_ADDR + 4)) /* eGON.BT0 */
		return BOOT_DEVICE_BOARD;

	/* The BROM will try to boot from mmc0 first, so try that first. */
#ifdef CONFIG_MMC
	mmc_initialize(gd->bd);
	mmc0 = find_mmc_device(0);
	if (sunxi_mmc_has_egon_boot_signature(mmc0))
		return BOOT_DEVICE_MMC1;
#endif

	/* Fallback to booting NAND if enabled. */
	if (IS_ENABLED(CONFIG_SPL_NAND_SUPPORT))
		return BOOT_DEVICE_NAND;

#ifdef CONFIG_MMC
	if (CONFIG_MMC_SUNXI_SLOT_EXTRA == 2) {
		mmc1 = find_mmc_device(1);
		if (sunxi_mmc_has_egon_boot_signature(mmc1))
			return BOOT_DEVICE_MMC2;
	}
#endif

	panic("Could not determine boot source\n");
	return -1;		/* Never reached */
}

/* No confirmation data available in SPL yet. Hardcode bootmode */
u32 spl_boot_mode(void)
{
	return MMCSD_MODE_RAW;
}

void board_init_f(ulong dummy)
{
	spl_init();
	preloader_console_init();

#ifdef CONFIG_SPL_I2C_SUPPORT
	/* Needed early by sunxi_board_init if PMU is enabled */
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
#endif
	sunxi_board_init();
}
#endif

void reset_cpu(ulong addr)
{
#ifdef CONFIG_SUNXI_GEN_SUN4I
	static const struct sunxi_wdog *wdog =
		 &((struct sunxi_timer_reg *)SUNXI_TIMER_BASE)->wdog;

	/* Set the watchdog for its shortest interval (.5s) and wait */
	writel(WDT_MODE_RESET_EN | WDT_MODE_EN, &wdog->mode);
	writel(WDT_CTRL_KEY | WDT_CTRL_RESTART, &wdog->ctl);

	while (1) {
		/* sun5i sometimes gets stuck without this */
		writel(WDT_MODE_RESET_EN | WDT_MODE_EN, &wdog->mode);
	}
#endif
#ifdef CONFIG_SUNXI_GEN_SUN6I
	static const struct sunxi_wdog *wdog =
		 ((struct sunxi_timer_reg *)SUNXI_TIMER_BASE)->wdog;

	/* Set the watchdog for its shortest interval (.5s) and wait */
	writel(WDT_CFG_RESET, &wdog->cfg);
	writel(WDT_MODE_EN, &wdog->mode);
	writel(WDT_CTRL_KEY | WDT_CTRL_RESTART, &wdog->ctl);
	while (1) { }
#endif
}

#ifndef CONFIG_SPL_BUILD

#define PLL1_CFG_REG (0x01C20000)

unsigned long get_pll1(void)
{
	u32 cfg = readl(PLL1_CFG_REG);
	u32 p = 1 << ((cfg >> 16) & 3);
	u32 n = (cfg >> 8) & 0x1F;
	u32 k = ((cfg >> 4) & 3) + 1;
	u32 m = ((cfg >> 0) & 3) + 1;
	u32 clk = ((u32)24000000 * n * k) / (m * p);
	return clk;
}

void setup_ccnt(void)
{
	u32 regval;
	asm volatile("mrc p15, 0, %0, c9, c12, 0" : "=r" (regval));
	regval |= (1 << 3); /* increment every 64 cycles */
	regval |= (1 << 0); /* enable counters */
	asm volatile("mcr p15, 0, %0, c9, c12, 0" :: "r" (regval));
	/* enable CCNT */
	asm volatile("mcr p15, 0, %0, c9, c12, 1" :: "r"(1 << 31));
}

static inline u32 get_ccnt(void)
{
	u32 regval;
	asm volatile("mrc p15, 0, %0, c9, c13, 0": "=r" (regval));
	return regval;
}

#define SUN4I_CTL_ENABLE                        BIT(0)
#define SUN4I_CTL_MASTER                        BIT(1)
#define SUN4I_CTL_CPHA                          BIT(2)
#define SUN4I_CTL_CPOL                          BIT(3)
#define SUN4I_CTL_CS_ACTIVE_LOW                 BIT(4)
#define SUN4I_CTL_LMTF                          BIT(6)
#define SUN4I_CTL_TF_RST                        BIT(8)
#define SUN4I_CTL_RF_RST                        BIT(9)
#define SUN4I_CTL_XCH                           BIT(10)
#define SUN4I_CTL_CS_MASK                       0x3000
#define SUN4I_CTL_CS(cs)                        (((cs) << 12) & SUN4I_CTL_CS_MASK)
#define SUN4I_CTL_DHB                           BIT(15)
#define SUN4I_CTL_CS_MANUAL                     BIT(16)
#define SUN4I_CTL_CS_LEVEL                      BIT(17)
#define SUN4I_CTL_TP                            BIT(18)

#define CCM_SPI2_CLK                            (0x01C20000 + 0xA8)
#define CCM_AHB_GATING0                         (0x01C20000 + 0x60)

#define SPI2_CCTL                               (0x01C17000 + 0x1C)
#define SPI2_CTL                                (0x01C17000 + 0x08)
#define SPI2_RX                                 (0x01C17000 + 0x00)
#define SPI2_TX                                 (0x01C17000 + 0x04)
#define SPI2_FIFO_STA                           (0x01C17000 + 0x28)
#define SPI2_TC                                 (0x01C17000 + 0x24)
#define SPI2_DMACTL                             (0x01C17000 + 0x14)
#define SPI2_BC                                 (0x01C17000 + 0x20)
#define SPI2_XMIT_CNT                           (0x01C17000 + 0x24)

/*
 * Configure the SPI2 pin muxing and setup clocks.
 */
static void setup_spi2(void)
{
	u32 reg_val;

#if defined(CONFIG_MACH_SUN5I)
	/* SPI2 in PE0-PE3 pins */
	sunxi_gpio_set_cfgpin(SUNXI_GPE(0), SUN5I_GPE_SPI2);
	sunxi_gpio_set_cfgpin(SUNXI_GPE(1), SUN5I_GPE_SPI2);
	sunxi_gpio_set_cfgpin(SUNXI_GPE(2), SUN5I_GPE_SPI2);
	sunxi_gpio_set_cfgpin(SUNXI_GPE(3), SUN5I_GPE_SPI2);
	sunxi_gpio_set_pull(SUNXI_GPE(0), SUNXI_GPIO_PULL_UP);
#elif defined(CONFIG_MACH_SUN4I) || defined(CONFIG_MACH_SUN7I)
	/* SPI2 on PC19-PC22 pins */
	sunxi_gpio_set_cfgpin(SUNXI_GPC(19), SUNXI_GPC_SPI2);
	sunxi_gpio_set_cfgpin(SUNXI_GPC(20), SUNXI_GPC_SPI2);
	sunxi_gpio_set_cfgpin(SUNXI_GPC(21), SUNXI_GPC_SPI2);
	sunxi_gpio_set_cfgpin(SUNXI_GPC(22), SUNXI_GPC_SPI2);
	sunxi_gpio_set_pull(SUNXI_GPC(19), SUNXI_GPIO_PULL_UP);
#else
#error SPI2 pin muxing configuration is needed
#endif

	reg_val = readl(CCM_AHB_GATING0);
	reg_val |= (1 << 22);
	writel(reg_val, CCM_AHB_GATING0); /* CCM_AHB_GATE_SPI2; */

	writel((1 << 31), CCM_SPI2_CLK);  /* 24MHz from OSC24M */

	/* Enable SPI2 as SPI slave */
	reg_val = readl(SPI2_CTL);
	reg_val &= ~SUN4I_CTL_MASTER;
	reg_val |= SUN4I_CTL_ENABLE | SUN4I_CTL_TF_RST | SUN4I_CTL_RF_RST;
	writel(reg_val, SPI2_CTL);
}

/*
 * This is a hackish implementation, which only supports the READ DATA BYTES
 * command, tries to predict the desired output and has some sanity checks
 * to verify if the assumptions were correct. We can't really implement a
 * correct handling of the protocol because the timing constraints are too
 * tight.
 *
 * The Allwinner's BROM first requests 256 bytes starting from the address 0,
 * verifies correctness of the header and then rewinds back to the address 0
 * and starts requesting 2048 byte blocks one after another. We just produce
 * this particular output and the BROM seems to be happy.
 *
 * TD;TR; use SPI2 on Allwinner A13 to do a limited SPI NOR flash emulation.
 */
static void emulate_spi_flash(void)
{
	unsigned long before, after;
	int txdatacount = 0, rxcount = 0;
	int offs = 0;
	unsigned before_ccnt = 0, after_ccnt = 0;

	setup_ccnt();
	setup_spi2();

	printf("\nEmulating SPI NOR flash on SPI2...\n");

	/* The dummy padding data, to be exchanged with the first command */
	writeb(0, SPI2_TX);
	writeb(0, SPI2_TX);
	writeb(0, SPI2_TX);
	writeb(0, SPI2_TX);

	/* Fill the TX buffer */
	for (offs = 0; offs < 48; offs++) {
		writeb(spi_flash_data[offs], SPI2_TX);
		txdatacount++;
	}

	/* Wait until we receive something */
	while ((readl(SPI2_FIFO_STA) & 0x7F) == 0) {}

	before = timer_get_us();

	while (1) {
		int rxfifo = readl(SPI2_FIFO_STA) & 0x7F;
		int txfifo = (readl(SPI2_FIFO_STA) >> 16) & 0x7F;

		if (txfifo < 32) {
			if (txdatacount == 256) {
				writeb(0, SPI2_TX);
				writeb(0, SPI2_TX);
				writeb(0, SPI2_TX);
				writeb(0, SPI2_TX);
				offs = 0;
			} else if ((txdatacount - 256) % 2048 == 0) {
				writeb(0, SPI2_TX);
				writeb(0, SPI2_TX);
				writeb(0, SPI2_TX);
				writeb(0, SPI2_TX);
			}
			writeb(spi_flash_data[offs++], SPI2_TX);
			writeb(spi_flash_data[offs++], SPI2_TX);
			writeb(spi_flash_data[offs++], SPI2_TX);
			writeb(spi_flash_data[offs++], SPI2_TX);
			txdatacount += 4;
		}

		if (txfifo < 16) {
			printf("Error: txfifo underflow\n");
			while (1) {};
		}

		if (rxfifo >= 4) {
			int b1 = readb(SPI2_RX);
			int b2 = readb(SPI2_RX);
			int b3 = readb(SPI2_RX);
			int b4 = readb(SPI2_RX);
			int addr = (b2 << 16) | (b3 << 8) | b4;

			if ((rxcount - 260) % 2052 == 0) {
				before_ccnt = get_ccnt();
				if (b1 != 3) {
					printf("Error: unexpected command %d (wanted READ DATA BYTES)\n", b1);
					while (1) {};
				}
				if (((rxcount - 260) / 2052) * 2048 != addr) {
					printf("Error: unexpected address %d for READ DATA BYTES\n", addr);
					while (1) {};
				}
			}
			rxcount += 4;
		}

		if (rxfifo > 48) {
			printf("Error: rxfifo overflow\n");
			while (1) {};
		}

		if (offs >= sizeof(spi_flash_data)) {
			while ((txfifo = (readl(SPI2_FIFO_STA) >> 16) & 0x7F)) {}
			break;
		}
	}

	after_ccnt = get_ccnt();
	after = timer_get_us();
	printf("All %d bytes of the emulated NOR flash data have been sent.\n",
	       (int)sizeof(spi_flash_data));
	if (after != before)
		printf("The average transfer speed: %d KB/s.\n",
		       (int)(1000 * txdatacount / (after - before)));
	if (after_ccnt != before_ccnt)
		printf("SPI clock = %d KHz\n",
		       (int)(get_pll1() / 1000 / 8 * 2048 / (after_ccnt - before_ccnt)));
}

#endif

#ifndef CONFIG_SYS_DCACHE_OFF
void enable_caches(void)
{
	/* Enable D-cache. I-cache is already enabled in start.S */
	dcache_enable();

#ifndef CONFIG_SPL_BUILD
	/*
	 * We have just enabled the D-cache and have everything ready,
	 * this is a convinient place to inject the SPI demo
	 */
	while (1) {
		emulate_spi_flash();
	}
#endif
}
#endif

#ifdef CONFIG_CMD_NET
/*
 * Initializes on-chip ethernet controllers.
 * to override, implement board_eth_init()
 */
int cpu_eth_init(bd_t *bis)
{
	__maybe_unused int rc;

#ifdef CONFIG_MACPWR
	gpio_request(CONFIG_MACPWR, "macpwr");
	gpio_direction_output(CONFIG_MACPWR, 1);
	mdelay(200);
#endif

#ifdef CONFIG_SUNXI_GMAC
	rc = sunxi_gmac_initialize(bis);
	if (rc < 0) {
		printf("sunxi: failed to initialize gmac\n");
		return rc;
	}
#endif

	return 0;
}
#endif
